---
title: "Importacion"
output: github_document
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Creación de un objeto de Series de Tiempo y gráficas
## Serie de interés

Este script se basa en el libro: Hands-on Time Series Analysis with R(2019) del autor Rami Krispin.

```{r importacion}
library(TSstudio)
tipos88 <- read.table("tipos88.dat", quote="\"", comment.char="")
Intanual=tipos88$V5  #Tipo de interés Anual
plot(as.ts(Intanual))
```

## Creando y graficando la serie de retornos para ver los cambios


El objeto ts es un formato para series de tiempo univariadas regulares. Las caraterísticas de una serie regular son; Ciclo o periodo(unidad de tiempo regular y repetitiva que divide la serie en ubconjuntos consecutivos e igualmente espaciados), Frecuencia(define la longitud o el número de unidades de un cíclo) y las marcas de tiempo(provee el tiempo en que cada observación fue obtenida y puede ser usada como índice de la serie. La diferencia($\delta$) entre los tiempos de dos observaciones consecutivas debe ser igual).

Este objeto ts tiene dos elementos: los valores de la serie y sus correspondientes marcas de tiempo.

El problema con el objeto ts es que las marcas de tiempo no soporta mútiples cíclos, es decir, series diarias con ciclos semanales y ciclos anuales. Adicionalmente, en los casos en que la marca de tiempo de la serie tenga más de dos elementos, como la fecha o la hora, no es posible recuperar el valor original de la marca de tiempo de la serie, ya que uno o más elementos se pierden durante el proceso de transformación. Ver ejemplo página 73, en donde el día de la fecha se pierde al transformarse el data frame en una objeto ts.

```{r retornos interes}
camrelintanual=log(Intanual[2:length(Intanual)]/Intanual[1:(length(Intanual)-1)])
sercamrelint=ts(camrelintanual,start=c(1988,01),frequency=12)
sercamrelint
plot(sercamrelint,main="Cambios relativos")
plot.ts(sercamrelint)
acf(sercamrelint,ci.type='ma')
acf(sercamrelint,type='partial')
str(sercamrelint)
head(time(sercamrelint),20)
head(cycle(sercamrelint),15)
frequency(sercamrelint)
deltat(sercamrelint)###en este caso es 1/12
ts_info(sercamrelint)
```

```{r gráfico interactivo}
TSstudio::ts_plot(sercamrelint,title="",slider=TRUE)
```


```{r grafico interactivo}
library(dygraphs)
dygraph(sercamrelint,main="Gráfico de Retorno Interés Anual", ylab="Cambios relativos del tipo de interés anual")%>% dyRangeSelector()
```



El Paquete zoo se puede usar para trabajar con series regulares e irregulares espaciadas en el tiempo. Tiene dos componentes: la estructura de los datos y el vector de índices.
```{r TSstudio}
data(EURO_Brent)
library(zoo)####

ts_info(EURO_Brent)
class(EURO_Brent)####Es un objeto zoo y es una serie regularmente espaciada zooreg
head(index(EURO_Brent))
class(index(EURO_Brent))
attributes(index(EURO_Brent))
###Podemos cambiar la clase
index(EURO_Brent) <- as.Date(index(EURO_Brent))
head(EURO_Brent)
class(index(EURO_Brent))

```
## Creación de objetos zoo
Vamos a crear objetos reguslar e irregularmente espaciados
```{r creacion de objetos zoo}
data(US_indicators)
str(US_indicators)
Ventas_vehiculos1=zoo(x=US_indicators$`Vehicle Sales`,frequency=12)  #Crea un objeto zoo de frecuencia 12, note que el crea el índice automáticamente
class(Ventas_vehiculos1)
frequency(Ventas_vehiculos1)
head(Ventas_vehiculos1)
class(index(Ventas_vehiculos1))
###establecemos cual es el índice
Ventas_vehiculos2=zoo(x = US_indicators$`Vehicle Sales`,
                         order.by = US_indicators$Date,
frequency = 12)
head(Ventas_vehiculos2)
class(Ventas_vehiculos2)
class(index(Ventas_vehiculos2))
#TSstudio::ts_plot(Ventas_vehiculos1)
TSstudio::ts_plot(Ventas_vehiculos2)
plot(Ventas_vehiculos1)
plot(Ventas_vehiculos2)
is.regular(Ventas_vehiculos1,strict = TRUE)
is.regular(Ventas_vehiculos1,strict = FALSE)


is.regular(Ventas_vehiculos2,strict = TRUE) ###Por contener año bisiesto no es estrictamente una serie regualr.
is.regular(Ventas_vehiculos2,strict = FALSE)
```

##  Paquete xts

El paquete xts(extensible time series) es una extsnión del paquete zoo y provee la clase xts y un conjunto de funciones y herramientas para pre-procesamiento, manipulacion y visualización de series de tiempo. Recuerde que una clase xts es un objeto zoo con atributos adicionales. 
```{r xts}
library(xts)
library(readxl)
data("Michigan_CS")###De TSstudio
ts_info(Michigan_CS)
class(Michigan_CS) #xts y zoo, lo cual es estándar en objeto xts.
frequency(Michigan_CS)
is.regular(Michigan_CS, strict = TRUE)
head(Michigan_CS)
plot(Michigan_CS)
```

```{r covertir dataframe en objeto xts}
US_indicators
str(US_indicators)

US_indicators_xts=xts(x = US_indicators[,c("Vehicle Sales",
   "Unemployment Rate")],frequency = 12,
order.by = US_indicators$Date)
head(US_indicators_xts)
ts_info(US_indicators_xts)
class(US_indicators_xts)
frequency(US_indicators_xts)
####Retornando a los datos de Michigan
periodicity(Michigan_CS)
periodicity(US_indicators_xts)

tclass(Michigan_CS)

tclass(US_indicators_xts)

tformat(Michigan_CS) <- "%m-%d-%Y"
head(Michigan_CS)
```



```{r Colcap}
Colcap<- read_excel("Datos históricos COLCAP-3.xlsx")

TsColCap=xts(Colcap$Ultimo, order.by = as.Date(Colcap$Fecha, "%Y-%m-%d"))
plot(TsColCap)

acf(TsColCap)
str(TsColCap)
```


## Fecha y formatos de hora
El pauqte base provee 2 tipos de clases de fechas y horas:

Date:Es una representación simple usando el formato de fecha YYYY-m-d

POSIXct/POSIXlt: También conocido como Clases DateTime  y el formato estandar es YYYY-m-d H:M:S. 
```{r Fecha y formatos de tiempo}
library(lubridate)
#Formato Date
fecha <- as.Date("2014-5-12")
fecha
class(fecha)  


###Formato POSIXct/POSIXlt
hora_ct <- as.POSIXct("2014-5-12 20:05:35", tz = "EST")
hora_ct
class(hora_ct)
```

```{r Reformateando y convirtiendo objetos de fecha}
url <-
   "https://github.com/PacktPublishing/Hands-On-Time-Series-Analysis-with-R/raw/master/Chapter02/dates_formats.csv"
dates_df <- read.csv(url, stringsAsFactors = FALSE)
str(dates_df)
###Convierte directamente de caractér a Fecha
dates_df$Japanese_format_new <- as.Date(dates_df$Japanese_format)

head(dates_df[, c("Japanese_format", "Japanese_format_new")])
identical(dates_df$Japanese_format, dates_df$Japanese_format_new)
class(dates_df$Japanese_format)  ###Los diferentes formatos uno caractér y el otro fecha
class(dates_df$Japanese_format_new)
```

