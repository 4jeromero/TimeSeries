---
title: "Analisis Descriptivo Series de Tiempo"
#output: github_document
output: html_document
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Gráfico de una Serie de tiempo

Vamos a analizar de forma descriptiva algunas serie de tiempo. Empezaremos por la serie de desempleo de los Estados Unidos que viene en el paquete TSstudio.
```{r DesempleoUS}
library(TSstudio)
data(USUnRate)
ts_info(USUnRate)
plot(USUnRate,main = "US Monthly Unemployment Rate",ylab="Unemployment Rate (%)")
```
La serie es medida mensula, es decir, presenta una frecuencia de 12.
Qué carcaterísticas podemos observar?
* Tendencia?
* Estacionalidad?
* Cíclos?
* Varianza marginal no constante?
Vamos a seleccionar un periodo de tiempo mas corto

```{r DesempleoUS selec periodo}
# unemployment <- window(USUnRate, start = c(1990,1))
#   ts_plot(unemployment,
#           title = "US Monthly Unemployment Rate",
#           Ytitle = "Unemployment Rate (%)",
#           Xtitle = "Year",
#           Xgrid = TRUE,
#Ygrid = TRUE)
```
Note que aquí podemos ver varias características: Estacionalidad(no es tan evidente), tres periodos de cíclos, el primero de 1990 a 2000,el segundo de 2000 a 2007, y el tercero de 2007 a 2019. No parece tener una hetocedasticidad marginal.

Veamos ahora la tasa de desempleo de Colombia. Hay que hacerle un ajuste a la base de datos porque está en order descendente en el tiempo.

## Including Plots
```{r Desempleo y empleo importacion y ajuste}
library(readxl)
library(tidyverse)
DesempleoyEmpleo <- read_excel("DesempleoyEmpleo.xlsx", range="A9:C249")
str(DesempleoyEmpleo)
DesempleoyEmpleo_1=DesempleoyEmpleo %>% map_df(rev)
tail(DesempleoyEmpleo)
head(DesempleoyEmpleo_1)
```

```{r creacion serie desempleo}
library(zoo)
library(xts)
Fechas=as.yearmon(DesempleoyEmpleo_1$Fecha)
Desempleo_Col_xts=xts(x = DesempleoyEmpleo_1$Tasadedesempleo,frequency = 12,
order.by = Fechas)
ts_info(Desempleo_Col_xts)
plot(Desempleo_Col_xts)
```

```{r grafico TSstudio Desemplo Col}
#ts_plot(Desempleo_Col_xts,
#           title = "Tasa de Desemplo Mensual Colombia",
#           Ytitle = "Tasa de Desempleo(%)",
#           Xtitle = "Año",
#           Xgrid = TRUE,
#Ygrid = TRUE)
```
Qué características presenta esta serie?


## Análisis de Tendencias
Vamos a ver la forma de estimar la tendencia y/o eliminarla.
```{r chicken1}
library(astsa)
library(TSstudio)
data(chicken)
ts_info(chicken)
plot(chicken,main="Precio Mensual de la Libra de Pollo en Estados Unidos", ylab="Precio en Centavos de Dólar")
#ts_plot(chicken)
```
Al parecer la serie de precios mensuales del pollo presenta una tendencia creciente al parecer lineal, es decir
$$y_t=\mu_t+a_t$$
o mas específicamente

$$y_t=\beta_0+\beta_1 t +a_t$$
```{r chicken2}
summary(fit <- lm(chicken~time(chicken), na.action=NULL))
plot(chicken, ylab="centavos por libra") 
abline(fit,col = "red") # Se añade la recta ajusta
###Eliminamos la tendencia con la predicción la recta
ElimiTendchick=chicken-predict(fit)
plot(ElimiTendchick,main="Serie Chicken Sin tendencia")
```

```{r Caminata Aletoria con Drift}
set.seed(154) 
w = rnorm(200); x = cumsum(w) 
wd = w +.2; xd = cumsum(wd)
plot.ts(xd, ylim=c(-5,55), main="Caminata Aletoria", ylab='')
lines(x, col=4); abline(h=0, col=4, lty=2); abline(a=0, b=.2, lty=2)

```

```{r sin tendencia chicken}
par(mar = c(2,2,2,2))
fit = lm(chicken~time(chicken), na.action=NULL) # Regresión sobre el tiempo
par(mfrow=c(2,1))
plot(resid(fit), type="o", main="sin tendencia") 
plot(diff(chicken), type="o", main="Primera Diferencia") 


```
```{r acf chicken}
par(mar = c(3,2,3,2))
par(mfrow=c(3,1)) # plot ACFs
acf(chicken, 48, main="ACF Pollo")
acf(resid(fit), 48, main="ACF Sin tendencia") 
acf(diff(chicken), 48, main="ACF Primera Diferencia")
```

## Transformación de Box-Cox para Estabilizar la Varianza Marginal
 En ocaciones la serie presenta varianza marginal no constante a lo largo del tiempo, lo cual hace necesario tener en cuenta tal caracaterística. 
En este caso, se siguiere hacer una transformación de potencia para estabilizar la varianza. Esta familia de transformaciones se llaman transformaciones Box-Cox.

\begin{equation}
	\label{BoxCox}
	f_{\lambda}(u_{t})= \begin{cases}
		\lambda^{-1}(u^{\lambda}_{t}-1), &  \text{si  $u_{t} \geq 0$, para $\lambda>0$,}\\
		\ln(u_{t}), &\text{ si $u_{t}>0$, para $\lambda=0$}.
	\end{cases}
	\
\end{equation}

```{r BoxCox}
data("AirPassengers")
plot(AirPassengers)
#####Transformación Box-Cox
library(FitAR)
library(forecast)
forecast::BoxCox.lambda(AirPassengers, method = "guerrero", lower = 0, upper = 2) ###Me etrega el valor de lambda 
##method="loglik"
FitAR::BoxCox(AirPassengers)###Me entrega una gráfica

lAirPass=log(AirPassengers)
par(mar = c(3,2,3,2))
par(mfrow=c(2,1))
plot(AirPassengers,main="Serie de Pasajeros sin Transformar")
plot(lAirPass,main="Series con Trnaformación BoxCox")
```
Note que ahora usamos la misma función para verificar si en verdad la varianza fue estabilizada.ç

```{r R BoxCox chequeo Series transformada}
FitAR::BoxCox(lAirPass)
forecast::BoxCox.lambda(lAirPass, method = "guerrero", lower = -1, upper = 2)
```





Vamos a correr lo mismo pero en Python para la transformacion de BoxCox

#```{r configuración, include=FALSE}
#library(knitr) 
#library(reticulate)
#use_condaenv(condaenv = "Python38andR", conda = "auto", required = TRUE)
#pandas=import("pandas")
#knitr::knit_engines$set(python = reticulate::eng_python) 
#```



#```{python inicio}
#import sys
#print(sys.path)
#import pandas as pd
#import matplotlib.pylab as plt
#data = pd.read_csv('AirPassengers.csv')
#print(data)
#print('\n Data Types:')
#print(data.dtypes)
#con=data['Month']
#data['Month']=pd.to_datetime(data['Month'])
##data.set_index('Month', inplace=True)
#pasajeros=data.set_index('Month')
#check datatype of index

#convert to time series:
#ts = pasajeros['NPassengers']
#ts.head(10)

####Graficar la Serie#####
#plt.plot(ts)
#plt.title('AirPassengers')
#plt.show()




#```

#```{python inicio_1}
#ts.index.freq
#pasajeros.index.freq='MS'
#ts.index.freq='MS'
#ts.index

#####Transformación Box-Cox
#import scipy as sp
#import scipy.stats ####En ocasiones puede funcionar la línea 46 sin ésta línea.
#print(sp.stats.boxcox(ts,alpha=0.05))
#sp.stats.boxcox(data['NPassengers'],alpha=0.05)
#logAirp=sp.stats.boxcox(data['NPassengers'],lmbda=0)
#data = data.assign(logAirp=logAirp)   

#logpasajeros=data.set_index('Month')   
#logAirPass=  logpasajeros['logAirp'] 
#plt.plot(logAirPass)
#plt.show()
#sp.stats.boxcox(logAirp,alpha=0.05)
###Note que la transformación Box-Cox si sutión efecto.


#```

## Gráficas de Retardos
Vamos a hacer gráficos de dispersión para chequear que tipos de relaciones hay entre los retardos de la variable interés. Vamos a trabajar con algunas series, por ejemplo:
* Índice ambiental mensual (soi)(Southern Oscillation Index), el cual mide los cambios en la presión del aire, relacionados con las temperaturas de la superficie del mar en el Océano Pacífico central.
* la serie rec (reclutamiento asociada al soi), número de nuevos peces.
* Consumo mensual de gas natural en EE. UU.(USgas) medido en Billones de pies cúbicos.
Esto permite chequear si hay posibles relaciones no-lineales.
```{r dispersión retardos_1}
library(astsa)
data("soi")
ts_info(soi)
?soi

par(mar = c(2,2,2,2))
plot(soi, main="Indice soi")
par(mar = c(3,2,3,2))
astsa::lag1.plot(soi, 12)  ###El 12 indica cuantos retardos y_t-k contra y_t 
###Hacer la gráfica con x11()


```

```{r dispersion retardos_2}
#pdf('/Users/sergiocalderon/Documents/Documentos - iMac de Sergio/Documentos iMac Sergio/Notas de Clase/Notas de clase/Notas de Clase Series de Tiempo Univariadas/Graficas/DispersionSoiRec.pdf',paper="USr")
par(mar = c(3,2,3,2))
lag2.plot(soi, rec, 8)   #El 2 de lag2.plot es porque intervenienen dos serie de tiempo.

#dev.off()
lag2.plot(soi, rec, 8,corr=F)
```
Note que con la función ts_lags de TSstudio podemos hacer una gráfica similar.
```{r dispersion con TSstudio}
ts_lags(soi,lags=1:12)

```

## La función de autocorrelación simple o gráfico ACF

Cuando el proceso es estacionario, o al menos nompresenta tendencia, podemos usar el gráfico acf para explorar las posibles relaciones lineales a diferentes rezagos. En seguida mostramos la función de autocorrelación para el índice soi y la serie de nuevos peces. 

```{r acf1}
#pdf('/Users/sergiocalderon/Documents/Documentos - iMac de Sergio/Documentos iMac Sergio/Notas de Clase/Notas de clase/Notas de Clase Series de Tiempo Univariadas/Graficas/ACFsoiRec.pdf',paper="USr")
par(mfrow=c(2,1))
par(mar = c(2.7,2,2.7,2))
acf(soi, 48, main="Southern Oscillation Index")
acf(rec, 48, main="Recruitment")
#dev.off()
```

```{r ccf}
ccf(soi, rec, 48, main="SOI vs Recruitment", ylab="CCF")
```
## Detección de cíclos y estacionalidades
Podemos usar la función *TSstudio::ts_heatmap* para crear un mapa de calor. Este es un gráfico tridimensional, en donde en el eje x están los meses, y en el eje y están los años. Note en este caso que los meses de Diciembre,Enero, Febrero y Marzo presentan los valores mas oscuros, es decir los valores mas grandes a lo largo de los años, en contraste con los meses de Mayo a Septiembre  que presentan colores mas claros. Este es un típico comportamiento de la presencia de un cíclo estacional en la serie.    El flujo de color es horizontal.

```{r consumo gas}
 ts_plot(USgas,
           title = "US Monthly Natural Gas consumption",
           Ytitle = "Billion Cubic Feet",
           Xtitle = "Year",
           Xgrid = TRUE,
           Ygrid = TRUE)
```


```{r ciclos1}
TSstudio::ts_heatmap(USgas,title = "Mapa de Calor - Consumo de Gas Natural en EEUU")
```
Voy enfocarme en un periodo de la serie

```{r serie desempleo en un periodo}
 unemployment <- window(USUnRate, start = c(1990,1))
   ts_plot(unemployment,
           title = "US Monthly Unemployment Rate",
           Ytitle = "Unemployment Rate (%)",
           Xtitle = "Year",
           Xgrid = TRUE,
Ygrid = TRUE)
```
* The first cycle occurred between 1990 and 2000, which was close to an 11-year cycle
* The second cycle started in 2000 and ended in 2007, which was a 7-year cycle
* A third cycle, which began in 2007 and as of May 2019 has not been completed yet, which means that this has continued for more than 12 years



```{r ciclos2}
ts_heatmap(USUnRate,title = "Mapa de Calor - Tasa de Desempleo EEUU")
```
En este ejemplo, el flujo de color de la Tasa de Desempleo es vertical, lo que indica el estado del ciclo. En este caso, las franjas verticales más claras representan el final de un ciclo y el comienzo del siguiente. Asimismo, las franjas verticales más oscuras representan los picos del ciclo.

## Explorando mas herramientas para detección de Estacionalidad

Pueden haber múltiples estacionalidades(por lo general ocurren en series de alta frecuencia: diaria, cada hora, cada media y asi sucesivamente.) o una única estacionalidad.

```{r mas acerca de estacionalidad}
library(UKgrid)
UKgrid_xts <- extract_grid(type = "xts",
                              columns = "ND",
                              aggregate = "hourly",
                              na.rm = TRUE)
#extract_grid solo funciona para el conjunto de datos UKgrid
ts_plot(UKgrid_xts,
            title = "National Hourly Demand UK Grid",
            Ytitle = "Megawatts",
            Xtitle = "Year",
            Xgrid = TRUE,
            Ygrid = TRUE)
```
## Medidas descriptivas

```{r descriptivo consumo de Gas}
USgas_df <- data.frame(year = floor(time(USgas)), month = cycle(USgas),USgas = as.numeric(USgas))

USgas_df$month <- factor(month.abb[USgas_df$month], levels = month.abb)

library(dplyr)
USgas_summary <- USgas_df %>%group_by(month) %>%summarise(mean= mean(USgas),sd = sd(USgas))
USgas_summary

 library(plotly)
  plot_ly (data = USgas_summary, x = ~ month, y = ~ mean, type = "bar", name   = "Mean") %>%
   layout (title = "USgas - Monthly Average", yaxis =list(title = "Mean",   range = c(1500, 2700)))
  
  monthplot(USgas)
```
Note que basados en las estadísticas descriptivas podemos ver que las medias son distintas para algunos meses, incluso sin quitar la tendencia. A una misma conclusión llegamos basados en los gráficos. Estas son típicas características de que hay presente un ciclo estacional en la serie.

Por otro lado, la primera indicación de la posible existencia de múltiples patrones estacionales en la serie es una frecuencia alta, como por diaria, horaria y en minutos. En esos casos, hay más de una forma de establecer la frecuencia de la serie. Por ejemplo, si capturamos una serie de tiempo de frecuencia diaria, la frecuencia de la serie se puede configurar de la siguiente manera:
* Diariamente (o 365), asumiendo que el ciclo más apropiado es un año completo
* Días de semana (o 7) siempre que la oscilación del día de la semana sea más dominante que la del ciclo de año completo.

Al utilizar estadísticas descriptiva con este tipo de series, tendrá sentido aplicar este método para cada frecuencia potencial de la serie (o al menos las principales) con el fin de examinar si existe una indicación del patrón estacional. 

Por ejemplo, UKgrid es una serie de tiempo por horas, que la marca automáticamente como sospechosa de tener múltiples patrones estacionales. Potencialmente, como se mencionó anteriormente, la demanda horaria de electricidad podría tener tres patrones estacionales diferentes:

* Horaria: Este es probablemente el principal patrón estacional de la serie, ya que existe una relación directa entre la demanda de energía eléctrica y la hora del día (hay alta demanda durante el día y baja demanda durante la noche o al contrario).
* Día de la semana: La demanda de electricidad a lo largo del día se deriva, potencialmente, del día de la semana. Tendría sentido esperar un alto consumo durante los días laborables y una menor tasa de consumo durante el fin de semana.
* Mensual: como los patrones climáticos varían a lo largo del año, la cantidad de luz del día y otros factores estacionales podrían afectar la demanda de electricidad.

Usando el paquete <b>lubridate</b> crearemos las características.

```{r multiples patrones estacionales_1}
library(xts)
UKgrid_df <- data.frame(time = index(UKgrid_xts), UKgrid=as.numeric(UKgrid_xts))
str(UKgrid_df)
```
Ahora crearemos características estacionales basados en los periodos que deseamos explorar, por ejemplo hora del día,o día de la semana, o mes del año.

```{r creando patrones}
library(lubridate)
UKgrid_df$hour <- hour(UKgrid_df$time)
UKgrid_df$weekday <- wday(UKgrid_df$time, label = TRUE, abbr = TRUE)
UKgrid_df$month <- factor(month.abb[month(UKgrid_df$time)], levels =   month.abb)
head(UKgrid_df)
```
Vamos a empezar las exploraciones analizando el cilo horario.

```{r horario UKgrid}
 UKgrid_hourly <- UKgrid_df %>%
    dplyr::group_by(hour) %>%
    dplyr::summarise(mean = mean(UKgrid, na.rm = TRUE), sd = sd(UKgrid, na.rm
= TRUE))
str(UKgrid_hourly)
```
Vamos ahora a hacer la gráfica de la media y la desviación estándar con base en las horas. Note que esas gráficas en escalas diferentes, así que hay que usar un gráfico especial.

```{r horario UKgrid_1}
 plot_ly(UKgrid_hourly) %>%
      add_lines(x = ~ hour, y = ~ mean, name = "Media") %>%
      add_lines(x = ~ hour, y = ~ sd, name = "Desviación Estándar", yaxis =
   "y2",
                line = list(color = "red", dash = "dash", width = 3)) %>%
      layout(
        title = "La demanda nacional de electricidad - Promedio horario vs. Desviación Estándar",
        yaxis = list(title = "Media"),
        yaxis2 = list(overlaying = "y",
                      side = "right",
                      title = "Desviación Estándar"
        ),
        xaxis = list(title="Hora del Día"),
        legend = list(x = 0.05, y = 0.9),
        margin = list(l = 50, r = 50)
)
```
Qué podemos destacar del gráfico y de las estadísticas descriptivas?

* Hay poca demanda durante la noche (entre la medianoche y las 6 a.m.) y una alta demanda entre las horas de la mañana y la tarde.

* Existe una fuerte correlación entre la demanda promedio y su desviación estándar.

* La relativamente baja desviación estándar de la demanda promedio   durante la noche podría indicar que existe un fuerte efecto subestacional durante esas horas además de la estacionalidad horaria. Esto debería tener sentido, ya que son horas de sueño normales y, por lo tanto, en promedio, la demanda es razonablemente la misma durante los días de semana.

* Por otro lado, la alta desviación estándar a lo largo de las horas de alta demanda podría indicar que la demanda se distribuye de manera diferente en diferentes vistas de periodicidad (como día de la semana o mes del año).

Vamos a explorar el último punto, viendo la demanda a la madrugada(3 a.m) y empezando el día(9 a.m)

```{r exploracion_1}

   UKgrid_weekday <- UKgrid_df %>%
      dplyr::filter(hour == 3 | hour == 9) %>%
    dplyr::group_by(hour, weekday) %>%
    dplyr::summarise(mean = mean(UKgrid, na.rm = TRUE),
                     sd = sd(UKgrid, na.rm = TRUE))

UKgrid_weekday$hour <- factor(UKgrid_weekday$hour)
    plot_ly(data = UKgrid_weekday, x = ~ weekday, y = ~ mean, type =
   "bar",color = ~ hour) %>%
      layout(title = "The Hourly Average Demand by Weekday",
             yaxis = list(title = "Mean", range = c(30000, 75000)),
             xaxis = list(title = "Weekday"))
```
En el gráfico de barras anterior podemos ver que la demanda de electricidad a las 3 a.m. es relativamente estable durante todos los días de la semana, con una ligera diferencia entre el promedio durante los días laborables y los días del fin de semana (alrededor de un 2% diferente). Por otro lado, existe una diferencia entre la demanda del día laborable y el fin de semana a las 9 a.m. (es decir, la demanda del lunes es en promedio un 28% superior a la del domingo). Como era de esperar, esos resultados se alinearon con nuestras expectativas anteriores. 

Ahora podemos aprovechar esos conocimientos para examinar si existe un patrón estacional mensual en la serie. Ahora seleccionaremos las mismas horas (3 a.m. y 9 a.m.); sin embargo, esta vez agruparemos estos datos por mes (en lugar de días laborables):

```{r exploracion_2}
 UKgrid_month <- UKgrid_df %>%
      dplyr::filter(hour == 3 | hour == 9) %>%
    dplyr::group_by(hour, month) %>%
    dplyr::summarise(mean = mean(UKgrid, na.rm = TRUE),
                     sd = sd(UKgrid, na.rm = TRUE))
UKgrid_month$hour <- factor(UKgrid_month$hour)
    plot_ly(data = UKgrid_month, x = ~ month, y = ~ mean, type = "bar",color =
   ~ hour) %>%
      layout(title = "The Hourly Average Demand by Weekday",
             yaxis = list(title = "Mean", range = c(30000, 75000)),
             xaxis = list(title = "Month"))
```
Podemos ver en el gráfico de barras del resumen de agregación mensual que, en promedio, la demanda durante la noche (3 a.m.) y la mañana (9 a.m.) varía a lo largo de los meses del año. Además, hay un cambio significativo en la demanda durante la noche en comparación con la agregación entre semana. La variación de la serie de mes a mes indica la existencia de estacionalidad mensual en la serie.

### Usando gráficos de densidaddes para explorar la estacionalidad.

Otro enfoque para analizar patrones estacionales en datos de series de tiempo es trazar la distribución de las unidades de frecuencia mediante el uso de histogramas o gráficos de densidad. Esto nos permitirá examinar si cada unidad de frecuencia tiene una distribución única que puede distinguirla del resto de unidades. Para esto usaremos el paquete <b>ggplot2</b>. Vamos empezar con la serie USgas.

```{r exploración estacionalidad ggplot2_1 }
 library(ggplot2)
    ggplot(USgas_df, aes(x = USgas)) +
      geom_density(aes(fill = month)) +
      ggtitle("USgas - Kernel Density Estimates by Month") +
      facet_grid(rows = vars(as.factor(month)))
```

Podemos ver algunos indicios de un patrón estacional en la serie, ya que las gráficas de densidad no se superponen entre sí (con la excepción de algunos meses consecutivos, como mayo y junio). Además, podemos ver que, durante algunos meses, la forma de las distribuciones es más plana con colas largas (principalmente durante los meses de invierno, noviembre, diciembre y enero). Sin embargo, no olvidemos el efecto de la tendencia o el crecimiento de un año a otro (como sabemos del capítulo anterior, la serie de gas de Estados Unidos tuvo una tendencia lineal desde el año 2010) ya que no la eliminamos de la serie. Repitamos este proceso; esta vez quitando la tendencia de la serie USgas antes de graficarla. Vamos a eliminarle la tendencia, posteriormente los explicaremos.

```{r exploración estacionalidad ggplot2_2 }
USgas_df$USgas_detrend <- USgas_df$USgas - decompose(USgas)$trend
    ggplot(USgas_df, aes(x = USgas_detrend)) +
      geom_density(aes(fill = month)) +
      ggtitle("USgas - Estimación de la densidad vía Kernel por mes") +
      facet_grid(rows = vars(as.factor(month)))
```
Podemos ver que hay un comportamiento similar pero ahora las colas de las densidades estimadas son mas cortas.Pueden hacer lo mismo pero en vez de quitar la tendencia, hacemos una diferenciación.

En el caso de que la distribución de la mayoría de las unidades de frecuencia sea plana con una cola larga, podría ser una indicación de múltiples patrones estacionales en la serie. Regresemos a la serie UKgrid y tracemos las gráficas de densidad de 24 horas:
```{r exploración de múltiples estacionalidades ggplot2_1}
UKgrid_df$hour <- as.factor(UKgrid_df$hour)
    ggplot(UKgrid_df, aes(x = UKgrid)) +
      geom_density(aes(fill = hour)) +
      ggtitle("UKgrid - Kernel Density Estimates by Hour of the day") +
      facet_grid(rows = vars(as.factor(hour)))
```
Como observamos anteriormente con las tablas de resúmenes estadísticos, la distribución de la demanda neta de electricidad durante la noche es relativamente estable (de ahí la distribución no plana con colas cortas en contraposición a la distribución plana con cola larga durante el día). Si ahora hacemos un subconjunto con una de las horas durante el día y trazamos su distribución por el día de la semana, deberíamos esperar una superposición durante la noche y poder distinguir entre la distribución durante los días de la semana y el fin de semana, en contraposición a solo el día de la semana.


Por ejemplo, la siguiente gráfica representa la distribución de la demanda a las 9 a.m. a lo largo de los días de la semana. Puede ver que la distribución durante los días de la semana se distingue de la del fin de semana:

```{r exploración de múltiples estacionalidades ggplot2_2}
UKgrid_df$weekday <- as.factor(UKgrid_df$weekday)
    UKgrid_df %>% dplyr::filter(hour == 0) %>%
    ggplot(aes(x = UKgrid)) +
      geom_density(aes(fill = as.factor(weekday))) +
      ggtitle("UKgrid - Kernel Density Estimates by Hour of the day") +
      facet_grid(rows = vars(as.factor(weekday)))

```

## Más herramientas del análisis de la estacionalidad
Vamos a usar el paquete forecast. Note que extraemos las subseries de los años. Lo cual demuestra un fuerte patrón estacional mensual.
```{r mas acerca estacionalidad_1}
library(forecast)
   ggseasonplot(USgas,year.labels=TRUE,continuous=TRUE)
   
ggseasonplot(USgas,  polar = TRUE)
```
Note que con el paquete TSstudio se puede hacer algo análogo.

```{r mas acerca estacionalidad_2}
ts_seasonal(USgas,type ="normal")

ts_seasonal(USgas, type = "cycle")

ts_seasonal(USgas, type = "box")

ts_seasonal(USgas, type = "all")
```
ts_seasonal con type="cycle" añade un orden cronológico, en este caso por mes. Esto puede permitir la identificación de un patrón estacional sin tener que quitar la tendencia.

Cuando en el argumento type="box", elabora un gráfico de caja por unidad de frecuencia.

Finalmente cuando en el argumento type="all", elabora todos los gráficos anteriores.
## Usando Regresión para Descubrir un cíclo