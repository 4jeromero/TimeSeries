---
title: "Analisis Descriptivo Series de Tiempo"
output: github_document
#output: html_document
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Gráfico de una Serie de tiempo

Vamos a analizar de forma descriptiva algunas serie de tiempo. Empezaremos por la serie de desempleo de los Estados Unidos que viene en el paquete TSstudio.
```{r DesempleoUS}
library(TSstudio)
data(USUnRate)
ts_info(USUnRate)
plot(USUnRate,main = "US Monthly Unemployment Rate",ylab="Unemployment Rate (%)")
```
La serie es medida mensula, es decir, presenta una frecuencia de 12.
Qué carcaterísticas podemos observar?
* Tendencia?
* Estacionalidad?
* Cíclos?
* Varianza marginal no constante?
Vamos a seleccionar un periodo de tiempo mas corto

```{r DesempleoUS selec periodo}
# unemployment <- window(USUnRate, start = c(1990,1))
#   ts_plot(unemployment,
#           title = "US Monthly Unemployment Rate",
#           Ytitle = "Unemployment Rate (%)",
#           Xtitle = "Year",
#           Xgrid = TRUE,
#Ygrid = TRUE)
```
Note que aquí podemos ver varias características: Estacionalidad(no es tan evidente), tres periodos de cíclos, el primero de 1990 a 2000,el segundo de 2000 a 2007, y el tercero de 2007 a 2019. No parece tener una hetocedasticidad marginal.

Veamos ahora la tasa de desempleo de Colombia. Hay que hacerle un ajuste a la base de datos porque está en order descendente en el tiempo.

## Including Plots
```{r Desempleo y empleo importacion y ajuste}
library(readxl)
library(tidyverse)
DesempleoyEmpleo <- read_excel("DesempleoyEmpleo.xlsx", range="A9:C249")
str(DesempleoyEmpleo)
DesempleoyEmpleo_1=DesempleoyEmpleo %>% map_df(rev)
tail(DesempleoyEmpleo)
head(DesempleoyEmpleo_1)
```

```{r creacion serie desempleo}
library(zoo)
library(xts)
Fechas=as.yearmon(DesempleoyEmpleo_1$Fecha)
Desempleo_Col_xts=xts(x = DesempleoyEmpleo_1$Tasadedesempleo,frequency = 12,
order.by = Fechas)
ts_info(Desempleo_Col_xts)
plot(Desempleo_Col_xts)
```

```{r grafico TSstudio Desemplo Col}
#ts_plot(Desempleo_Col_xts,
#           title = "Tasa de Desemplo Mensual Colombia",
#           Ytitle = "Tasa de Desempleo(%)",
#           Xtitle = "Año",
#           Xgrid = TRUE,
#Ygrid = TRUE)
```
Qué características presenta esta serie?


## Análisis de Tendencias
Vamos a ver la forma de estimar la tendencia y/o eliminarla.
```{r chicken1}
library(astsa)
library(TSstudio)
data(chicken)
ts_info(chicken)
plot(chicken,main="Precio Mensual de la Libra de Pollo en Estados Unidos", ylab="Precio en Centavos de Dólar")
#ts_plot(chicken)
```
Al parecer la serie de precios mensuales del pollo presenta una tendencia creciente al parecer lineal, es decir
$$y_t=\mu_t+a_t$$
o mas específicamente

$$y_t=\beta_0+\beta_1 t +a_t$$
```{r chicken2}
summary(fit <- lm(chicken~time(chicken), na.action=NULL))
plot(chicken, ylab="centavos por libra") 
abline(fit,col = "red") # Se añade la recta ajusta
###Eliminamos la tendencia con la predicción la recta
ElimiTendchick=chicken-predict(fit)
plot(ElimiTendchick,main="Serie Chicken Sin tendencia")
```

```{r Caminata Aletoria con Drift}
set.seed(154) 
w = rnorm(200); x = cumsum(w) 
wd = w +.2; xd = cumsum(wd)
plot.ts(xd, ylim=c(-5,55), main="Caminata Aletoria", ylab='')
lines(x, col=4); abline(h=0, col=4, lty=2); abline(a=0, b=.2, lty=2)

```

```{r sin tendencia chicken}
par(mar = c(2,2,2,2))
fit = lm(chicken~time(chicken), na.action=NULL) # Regresión sobre el tiempo
par(mfrow=c(2,1))
plot(resid(fit), type="o", main="sin tendencia") 
plot(diff(chicken), type="o", main="Primera Diferencia") 


```
```{r acf chicken}
par(mar = c(3,2,3,2))
par(mfrow=c(3,1)) # plot ACFs
acf(chicken, 48, main="ACF Pollo")
acf(resid(fit), 48, main="ACF Sin tendencia") 
acf(diff(chicken), 48, main="ACF Primera Diferencia")
```

## Transformación de Box-Cox para Estabilizar la Varianza Marginal
 En ocaciones la serie presenta varianza marginal no constante a lo largo del tiempo, lo cual hace necesario tener en cuenta tal caracaterística. 
En este caso, se siguiere hacer una transformación de potencia para estabilizar la varianza. Esta familia de transformaciones se llaman transformaciones Box-Cox.

\begin{equation}
	\label{BoxCox}
	f_{\lambda}(u_{t})= \begin{cases}
		\lambda^{-1}(u^{\lambda}_{t}-1), &  \text{si  $u_{t} \geq 0$, para $\lambda>0$,}\\
		\ln(u_{t}), &\text{ si $u_{t}>0$, para $\lambda=0$}.
	\end{cases}
	\
\end{equation}

```{r BoxCox}
data("AirPassengers")
plot(AirPassengers)
#####Transformación Box-Cox
library(FitAR)
library(forecast)
forecast::BoxCox.lambda(AirPassengers, method = "guerrero", lower = 0, upper = 2) ###Me etrega el valor de lambda 
##method="loglik"
FitAR::BoxCox(AirPassengers)###Me entrega una gráfica

lAirPass=log(AirPassengers)
par(mar = c(3,2,3,2))
par(mfrow=c(2,1))
plot(AirPassengers,main="Serie de Pasajeros sin Transformar")
plot(lAirPass,main="Series con Trnaformación BoxCox")
```
Note que ahora usamos la misma función para verificar si en verdad la varianza fue estabilizada.ç

```{r R BoxCox chequeo Series transformada}
FitAR::BoxCox(lAirPass)
forecast::BoxCox.lambda(lAirPass, method = "guerrero", lower = -1, upper = 2)
```





Vamos a correr lo mismo pero en Python para la transformacion de BoxCox

#```{r configuración, include=FALSE}
#library(knitr) 
#library(reticulate)
#use_condaenv(condaenv = "Python38andR", conda = "auto", required = TRUE)
#pandas=import("pandas")
#knitr::knit_engines$set(python = reticulate::eng_python) 
#```



#```{python inicio}
#import sys
#print(sys.path)
#import pandas as pd
#import matplotlib.pylab as plt
#data = pd.read_csv('AirPassengers.csv')
#print(data)
#print('\n Data Types:')
#print(data.dtypes)
#con=data['Month']
#data['Month']=pd.to_datetime(data['Month'])
##data.set_index('Month', inplace=True)
#pasajeros=data.set_index('Month')
#check datatype of index

#convert to time series:
#ts = pasajeros['NPassengers']
#ts.head(10)

####Graficar la Serie#####
#plt.plot(ts)
#plt.title('AirPassengers')
#plt.show()




#```

#```{python inicio_1}
#ts.index.freq
#pasajeros.index.freq='MS'
#ts.index.freq='MS'
#ts.index

#####Transformación Box-Cox
#import scipy as sp
#import scipy.stats ####En ocasiones puede funcionar la línea 46 sin ésta línea.
#print(sp.stats.boxcox(ts,alpha=0.05))
#sp.stats.boxcox(data['NPassengers'],alpha=0.05)
#logAirp=sp.stats.boxcox(data['NPassengers'],lmbda=0)
#data = data.assign(logAirp=logAirp)   

#logpasajeros=data.set_index('Month')   
#logAirPass=  logpasajeros['logAirp'] 
#plt.plot(logAirPass)
#plt.show()
#sp.stats.boxcox(logAirp,alpha=0.05)
###Note que la transformación Box-Cox si sutión efecto.


#```

## Gráficas de Retardos
Vamos a hacer gráficos de dispersión para chequear que tipos de relaciones hay entre los retardos de la variable interés. Vamos a trabajar con algunas series, por ejemplo:
* Índice ambiental mensual (soi)(Southern Oscillation Index), el cual mide los cambios en la presión del aire, relacionados con las temperaturas de la superficie del mar en el Océano Pacífico central.
* la serie rec (reclutamiento asociada al soi), número de nuevos peces.
* Consumo mensual de gas natural en EE. UU.(USgas) medido en Billones de pies cúbicos.
Esto permite chequear si hay posibles relaciones no-lineales.
```{r dispersión retardos_1}
library(astsa)
data("soi")
ts_info(soi)
?soi
par(mar = c(2,2,2,2))
plot(soi, main="Indice soi")
par(mar = c(3,2,3,2))
astsa::lag1.plot(soi, 12)  ###El 12 indica cuantos retardos y_t-k contra y_t 
###Hacer la gráfica con x11()
```

```{r dispersion retardos_2}
par(mar = c(3,2,3,2))
lag2.plot(soi, rec, 8)   #El 2 es porque intervenienen dos serie de tiempo.
```
Note que con la función ts_lags de TSstudio podemos hacer una gráfica similar.
```{r dispersion con TSstudio}
ts_lags(soi,lags=1:12)

```



