---
title: "Analisis Descriptivo Series de Tiempo"
output: github_document
#output: html_document
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Gráfico de una Serie de tiempo

Vamos a analizar de forma descriptiva algunas serie de tiempo. Empezaremos por la serie de desempleo de los Estados Unidos que viene en el paquete TSstudio.
```{r DesempleoUS}
library(TSstudio)
data(USUnRate)
ts_info(USUnRate)
plot(USUnRate,main = "US Monthly Unemployment Rate",ylab="Unemployment Rate (%)")
```
La serie es medida mensula, es decir, presenta una frecuencia de 12.
Qué carcaterísticas podemos observar?
* Tendencia?
* Estacionalidad?
* Cíclos?
* Varianza marginal no constante?
Vamos a seleccionar un periodo de tiempo mas corto

```{r DesempleoUS selec periodo}
# unemployment <- window(USUnRate, start = c(1990,1))
#   ts_plot(unemployment,
#           title = "US Monthly Unemployment Rate",
#           Ytitle = "Unemployment Rate (%)",
#           Xtitle = "Year",
#           Xgrid = TRUE,
#Ygrid = TRUE)
```
Note que aquí podemos ver varias características: Estacionalidad(no es tan evidente), tres periodos de cíclos, el primero de 1990 a 2000,el segundo de 2000 a 2007, y el tercero de 2007 a 2019. No parece tener una hetocedasticidad marginal.

Veamos ahora la tasa de desempleo de Colombia. Hay que hacerle un ajuste a la base de datos porque está en order descendente en el tiempo.

## Including Plots
```{r Desempleo y empleo importacion y ajuste}
library(readxl)
library(tidyverse)
DesempleoyEmpleo <- read_excel("DesempleoyEmpleo.xlsx", range="A9:C249")
str(DesempleoyEmpleo)
DesempleoyEmpleo_1=DesempleoyEmpleo %>% map_df(rev)
tail(DesempleoyEmpleo)
head(DesempleoyEmpleo_1)
```

```{r creacion serie desempleo}
library(zoo)
library(xts)
Fechas=as.yearmon(DesempleoyEmpleo_1$Fecha)
Desempleo_Col_xts=xts(x = DesempleoyEmpleo_1$Tasadedesempleo,frequency = 12,
order.by = Fechas)
ts_info(Desempleo_Col_xts)
plot(Desempleo_Col_xts)
```

```{r grafico TSstudio Desemplo Col}
#ts_plot(Desempleo_Col_xts,
#           title = "Tasa de Desemplo Mensual Colombia",
#           Ytitle = "Tasa de Desempleo(%)",
#           Xtitle = "Año",
#           Xgrid = TRUE,
#Ygrid = TRUE)
```
Qué características presenta esta serie?


## Análisis de Tendencias
Vamos a ver la forma de estimar la tendencia y/o eliminarla.
```{r chicken1}
library(astsa)
library(TSstudio)
data(chicken)
ts_info(chicken)
plot(chicken,main="Precio Mensual de la Libra de Pollo en Estados Unidos", ylab="Precio en Centavos de Dólar")
#ts_plot(chicken)
```
Al parecer la serie de precios mensuales del pollo presenta una tendencia creciente al parecer lineal, es decir
$$y_t=\mu_t+a_t$$
o mas específicamente

$$y_t=\beta_0+\beta_1 t +a_t$$
```{r chicken2}
summary(fit <- lm(chicken~time(chicken), na.action=NULL))
plot(chicken, ylab="centavos por libra") 
abline(fit,col = "red") # Se añade la recta ajusta
###Eliminamos la tendencia con la predicción la recta
ElimiTendchick=chicken-predict(fit)
plot(ElimiTendchick,main="Serie Chicken Sin tendencia")
```

```{r Caminata Aletoria con Drift}
set.seed(154) 
w = rnorm(200); x = cumsum(w) 
wd = w +.2; xd = cumsum(wd)
plot.ts(xd, ylim=c(-5,55), main="Caminata Aletoria", ylab='')
lines(x, col=4); abline(h=0, col=4, lty=2); abline(a=0, b=.2, lty=2)

```

```{r sin tendencia chicken}
par(mar = c(2,2,2,2))
fit = lm(chicken~time(chicken), na.action=NULL) # Regresión sobre el tiempo
par(mfrow=c(2,1))
plot(resid(fit), type="o", main="sin tendencia") 
plot(diff(chicken), type="o", main="Primera Diferencia") 


```
```{r acf chicken}
par(mar = c(3,2,3,2))
par(mfrow=c(3,1)) # plot ACFs
acf(chicken, 48, main="ACF Pollo")
acf(resid(fit), 48, main="ACF Sin tendencia") 
acf(diff(chicken), 48, main="ACF Primera Diferencia")
```

## Transformación de Box-Cox para Estabilizar la Varianza Marginal
 En ocaciones la serie presenta varianza marginal no constante a lo largo del tiempo, lo cual hace necesario tener en cuenta tal caracaterística. 
En este caso, se siguiere hacer una transformación de potencia para estabilizar la varianza. Esta familia de transformaciones se llaman transformaciones Box-Cox.

\begin{equation}
	\label{BoxCox}
	f_{\lambda}(u_{t})= \begin{cases}
		\lambda^{-1}(u^{\lambda}_{t}-1), &  \text{si  $u_{t} \geq 0$, para $\lambda>0$,}\\
		\ln(u_{t}), &\text{ si $u_{t}>0$, para $\lambda=0$}.
	\end{cases}
	\
\end{equation}

```{r BoxCox}
data("AirPassengers")
plot(AirPassengers)
#####Transformación Box-Cox
library(FitAR)
library(forecast)
forecast::BoxCox.lambda(AirPassengers, method = "guerrero", lower = 0, upper = 2) ###Me etrega el valor de lambda 
##method="loglik"
FitAR::BoxCox(AirPassengers)###Me entrega una gráfica

lAirPass=log(AirPassengers)
par(mar = c(3,2,3,2))
par(mfrow=c(2,1))
plot(AirPassengers,main="Serie de Pasajeros sin Transformar")
plot(lAirPass,main="Series con Trnaformación BoxCox")
```
Note que ahora usamos la misma función para verificar si en verdad la varianza fue estabilizada.ç

```{r R BoxCox chequeo Series transformada}
FitAR::BoxCox(lAirPass)
forecast::BoxCox.lambda(lAirPass, method = "guerrero", lower = -1, upper = 2)
```





Vamos a correr lo mismo pero en Python para la transformacion de BoxCox

#```{r configuración, include=FALSE}
#library(knitr) 
#library(reticulate)
#use_condaenv(condaenv = "Python38andR", conda = "auto", required = TRUE)
#pandas=import("pandas")
#knitr::knit_engines$set(python = reticulate::eng_python) 
#```



#```{python inicio}
#import sys
#print(sys.path)
#import pandas as pd
#import matplotlib.pylab as plt
#data = pd.read_csv('AirPassengers.csv')
#print(data)
#print('\n Data Types:')
#print(data.dtypes)
#con=data['Month']
#data['Month']=pd.to_datetime(data['Month'])
##data.set_index('Month', inplace=True)
#pasajeros=data.set_index('Month')
#check datatype of index

#convert to time series:
#ts = pasajeros['NPassengers']
#ts.head(10)

####Graficar la Serie#####
#plt.plot(ts)
#plt.title('AirPassengers')
#plt.show()




#```

#```{python inicio_1}
#ts.index.freq
#pasajeros.index.freq='MS'
#ts.index.freq='MS'
#ts.index

#####Transformación Box-Cox
#import scipy as sp
#import scipy.stats ####En ocasiones puede funcionar la línea 46 sin ésta línea.
#print(sp.stats.boxcox(ts,alpha=0.05))
#sp.stats.boxcox(data['NPassengers'],alpha=0.05)
#logAirp=sp.stats.boxcox(data['NPassengers'],lmbda=0)
#data = data.assign(logAirp=logAirp)   

#logpasajeros=data.set_index('Month')   
#logAirPass=  logpasajeros['logAirp'] 
#plt.plot(logAirPass)
#plt.show()
#sp.stats.boxcox(logAirp,alpha=0.05)
###Note que la transformación Box-Cox si sutión efecto.


#```

## Gráficas de Retardos
Vamos a hacer gráficos de dispersión para chequear que tipos de relaciones hay entre los retardos de la variable interés. Vamos a trabajar con algunas series, por ejemplo:
* Índice ambiental mensual (soi)(Southern Oscillation Index), el cual mide los cambios en la presión del aire, relacionados con las temperaturas de la superficie del mar en el Océano Pacífico central.
* la serie rec (reclutamiento asociada al soi), número de nuevos peces.
* Consumo mensual de gas natural en EE. UU.(USgas) medido en Billones de pies cúbicos.
Esto permite chequear si hay posibles relaciones no-lineales.
```{r dispersión retardos_1}
library(astsa)
data("soi")
ts_info(soi)
?soi

par(mar = c(2,2,2,2))
plot(soi, main="Indice soi")
par(mar = c(3,2,3,2))
astsa::lag1.plot(soi, 12)  ###El 12 indica cuantos retardos y_t-k contra y_t 
###Hacer la gráfica con x11()


```

```{r dispersion retardos_2}
#pdf('/Users/sergiocalderon/Documents/Documentos - iMac de Sergio/Documentos iMac Sergio/Notas de Clase/Notas de clase/Notas de Clase Series de Tiempo Univariadas/Graficas/DispersionSoiRec.pdf',paper="USr")
par(mar = c(3,2,3,2))
lag2.plot(soi, rec, 8)   #El 2 de lag2.plot es porque intervenienen dos serie de tiempo.

#dev.off()
lag2.plot(soi, rec, 8,corr=F)
```
Note que con la función ts_lags de TSstudio podemos hacer una gráfica similar.
```{r dispersion con TSstudio}
ts_lags(soi,lags=1:12)

```

## La función de autocorrelación simple o gráfico ACF

Cuando el proceso es estacionario, o al menos nompresenta tendencia, podemos usar el gráfico acf para explorar las posibles relaciones lineales a diferentes rezagos. En seguida mostramos la función de autocorrelación para el índice soi y la serie de nuevos peces. 

```{r acf1}
#pdf('/Users/sergiocalderon/Documents/Documentos - iMac de Sergio/Documentos iMac Sergio/Notas de Clase/Notas de clase/Notas de Clase Series de Tiempo Univariadas/Graficas/ACFsoiRec.pdf',paper="USr")
par(mfrow=c(2,1))
par(mar = c(2.7,2,2.7,2))
acf(soi, 48, main="Southern Oscillation Index")
acf(rec, 48, main="Recruitment")
#dev.off()
```

```{r ccf}
ccf(soi, rec, 48, main="SOI vs Recruitment", ylab="CCF")
```
## Detección de cíclos y estacionalidades
Podemos usar la función *TSstudio::ts_heatmap* para crear un mapa de calor. Este es un gráfico tridimensional, en donde en el eje x están los meses, y en el eje y están los años. Note en este caso que los meses de Diciembre,Enero, Febrero y Marzo presentan los valores mas oscuros, es decir los valores mas grandes a lo largo de los años, en contraste con los meses de Mayo a Septiembre  que presentan colores mas claros. Este es un típico comportamiento de la presencia de un cíclo estacional en la serie.    El flujo de color es horizontal.

```{r consumo gas}
 ts_plot(USgas,
           title = "US Monthly Natural Gas consumption",
           Ytitle = "Billion Cubic Feet",
           Xtitle = "Year",
           Xgrid = TRUE,
           Ygrid = TRUE)
```


```{r ciclos1}
TSstudio::ts_heatmap(USgas,title = "Mapa de Calor - Consumo de Gas Natural en EEUU")
```
Voy enfocarme en un periodo de la serie

```{r serie desempleo en un periodo}
 unemployment <- window(USUnRate, start = c(1990,1))
   ts_plot(unemployment,
           title = "US Monthly Unemployment Rate",
           Ytitle = "Unemployment Rate (%)",
           Xtitle = "Year",
           Xgrid = TRUE,
Ygrid = TRUE)
```
* The first cycle occurred between 1990 and 2000, which was close to an 11-year cycle
* The second cycle started in 2000 and ended in 2007, which was a 7-year cycle
* A third cycle, which began in 2007 and as of May 2019 has not been completed yet, which means that this has continued for more than 12 years



```{r ciclos2}
ts_heatmap(USUnRate,title = "Mapa de Calor - Tasa de Desempleo EEUU")
```
En este ejemplo, el flujo de color de la Tasa de Desempleo es vertical, lo que indica el estado del ciclo. En este caso, las franjas verticales más claras representan el final de un ciclo y el comienzo del siguiente. Asimismo, las franjas verticales más oscuras representan los picos del ciclo.

## Explorando mas herramientas para detección de Estacionalidad

Pueden haber múltiples estacionalidades(por lo general ocurren en series de alta frecuencia: diaria, cada hora, cada media y asi sucesivamente.) o una única estacionalidad.

```{r mas acerca de estacionalidad}
library(UKgrid)
UKgrid_xts <- extract_grid(type = "xts",
                              columns = "ND",
                              aggregate = "hourly",
                              na.rm = TRUE)
#extract_grid solo funciona para el conjunto de datos UKgrid
ts_plot(UKgrid_xts,
            title = "National Hourly Demand UK Grid",
            Ytitle = "Megawatts",
            Xtitle = "Year",
            Xgrid = TRUE,
            Ygrid = TRUE)
```
## Medidas descriptivas

```{r descriptivo consumo de Gas}
USgas_df <- data.frame(year = floor(time(USgas)), month = cycle(USgas),USgas = as.numeric(USgas))

USgas_df$month <- factor(month.abb[USgas_df$month], levels = month.abb)

library(dplyr)
USgas_summary <- USgas_df %>%group_by(month) %>%summarise(mean= mean(USgas),sd = sd(USgas))
USgas_summary

 library(plotly)
  plot_ly (data = USgas_summary, x = ~ month, y = ~ mean, type = "bar", name   = "Mean") %>%
   layout (title = "USgas - Monthly Average", yaxis =list(title = "Mean",   range = c(1500, 2700)))
  
  monthplot(USgas)
```
Note que basados en las estadísticas descriptivas podemos ver que las medias son distintas para algunos meses, incluso sin quitar la tendencia. A una misma conclusión llegamos basados en los gráficos. Estas son típicas características de que hay presente un ciclo estacional en la serie.

Por otro lado, la primera indicación de la posible existencia de múltiples patrones estacionales en la serie es una frecuencia alta, como por diaria, horaria y en minutos. En esos casos, hay más de una forma de establecer la frecuencia de la serie. Por ejemplo, si capturamos una serie de tiempo de frecuencia diaria, la frecuencia de la serie se puede configurar de la siguiente manera:
* Diariamente (o 365), asumiendo que el ciclo más apropiado es un año completo
* Días de semana (o 7) siempre que la oscilación del día de la semana sea más dominante que la del ciclo de año completo.

Al utilizar estadísticas descriptiva con este tipo de series, tendrá sentido aplicar este método para cada frecuencia potencial de la serie (o al menos las principales) con el fin de examinar si existe una indicación del patrón estacional. 

Por ejemplo, UKgrid es una serie de tiempo por horas, que la marca automáticamente como sospechosa de tener múltiples patrones estacionales. Potencialmente, como se mencionó anteriormente, la demanda horaria de electricidad podría tener tres patrones estacionales diferentes:

* Horaria: Este es probablemente el principal patrón estacional de la serie, ya que existe una relación directa entre la demanda de energía eléctrica y la hora del día (hay alta demanda durante el día y baja demanda durante la noche).
Día de la semana: La demanda de electricidad a lo largo del día se deriva, potencialmente, del día de la semana. Tendría sentido esperar un alto consumo durante los días laborables y una menor tasa de consumo durante el fin de semana.
Mensual: como los patrones climáticos varían a lo largo del año, la cantidad de luz del día y otros factores estacionales podrían afectar la demanda de electricidad.

```{r multiples patrones estacionales_1}
library(xts)
UKgrid_df <- data.frame(time = index(UKgrid_xts), UKgrid=as.numeric(UKgrid_xts))
str(UKgrid_df)
```
Ahora crearemos características estacionales basados en los periodos que deseamos explorar, por ejemplo hora del día,o día de la semana, o mes del año usando lubridate.

```{r creando patrones}
library(lubridate)
UKgrid_df$hour <- hour(UKgrid_df$time)
UKgrid_df$weekday <- wday(UKgrid_df$time, label = TRUE, abbr = TRUE)
UKgrid_df$month <- factor(month.abb[month(UKgrid_df$time)], levels =   month.abb)
head(UKgrid_df)
```


## Usando Regresión para Descubrir un cíclo